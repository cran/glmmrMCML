% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{mcml_optim_sparse}
\alias{mcml_optim_sparse}
\title{Likelihood maximisation for the GLMM using sparse matrix methods}
\usage{
mcml_optim_sparse(
  cov,
  data,
  eff_range,
  Ap,
  Ai,
  Z,
  X,
  y,
  u,
  family,
  link,
  start,
  trace,
  mcnr = FALSE
)
}
\arguments{
\item{cov}{An integer matrix with columns of block identifier, dimension of block, function definition, number of variables
in the argument to the funciton, and index of the parameters, respectively. Rows are specific functions of each block.}

\item{data}{Vector of data. Created by flattening the matrices in column-major order of the data used in each block.}

\item{eff_range}{Vector of values with the effective range parameters of the covariance functions, where required.}

\item{Ap}{Integer vector of pointers, one for each column, specifying the initial (zero-based) index of elements in the column. Slot `p`
of a matrix of a class defined in \link[Matrix]{sparseMatrix}}

\item{Ai}{Integer vector specifying the row indices of the non-zero elements of the matrix. Slot `i`
of a matrix of a class defined in \link[Matrix]{sparseMatrix}}

\item{Z}{Matrix Z of the GLMM}

\item{X}{Matrix X of the GLMM}

\item{y}{Vector of observations}

\item{u}{Matrix of samples of the random effects. Each column is a sample.}

\item{family}{Character specifying the family}

\item{link}{Character specifying the link function}

\item{start}{Vector of starting values for the optimisation}

\item{trace}{Integer indicating what to report to the console, 0= nothing, 1-3=detailed output}

\item{mcnr}{Logical indicating whether to use Newton-Raphson (TRUE) or Expectation Maximisation (FALSE)}
}
\value{
A vector of the parameters that maximise the simulated likelihood
}
\description{
Given model data and random effects samples `u`, this function will run the MCML steps to generate new estimates of 
mean function and covariance parameters. This version of the function uses sparse matrix methods for the operations involving
the random effects covariance matrix, see \link[Matrix]{dsCMatrix-class} for specification. 
These functions are not intended to be used by the general user since 
the complete model fitting algorithm can be accessed through the member functions of the \link[glmmrMCML]{ModelMCML} 
class. These functions are exported for users wishing to use the modular components or each step 
separately of the MCML algorithm.
}
\details{
Likelihood maximisation for the GLMM
}
\examples{
## small example with simulated data
## create data and model object with 
## parameters to simulate data and 
## act as starting values
df <- nelder(~(j(8) * t(3)) > i(4))
des <- ModelMCML$new(
 covariance = list(
  formula =  ~(1|gr(j)*ar1(t)),
  parameters = c(0.25,0.7)
),
mean = list(
  formula = ~factor(t)-1,
  parameters = rnorm(3)
),
data=df,
family=gaussian()
)
## simulate data
y <- des$sim_data()
## get covariance definition matrix
ddata <- des$covariance$get_D_data()
## simulate some values of the random effects
## first, we need to extract the Cholesky decomposition of the covariance matrix D
L <- des$covariance$get_chol_D()
## generate samples using HMC - note this step does not use the sparse matrix
mat <- mcmc_sample(Z = as.matrix(des$covariance$Z),
   L = as.matrix(L),
   X = as.matrix(des$mean_function$X),
   y = as.vector(y),
   beta = des$mean_function$parameters,
   var_par = 1,
   family = des$mean_function$family[[1]],
   link = des$mean_function$family[[2]],
   warmup = 250, 
   nsamp = 250,
   lambda = 5,
   maxsteps = 100,
   trace=1,
   target_accept = 0.95)
## the specification of the covariance above results in a sparse covariance matrix,
## so we can just extract the components as below.
out <- mcml_optim_sparse(cov=ddata$cov,
   data=ddata$data,
   eff_range = rep(0,30),
   Ap = des$covariance$D@p,
   Ai = des$covariance$D@i,
   Z = as.matrix(des$covariance$Z),
   X = as.matrix(des$mean_function$X),
   y = y,
   u = mat,
   family = des$mean_function$family[[1]],
   link=des$mean_function$family[[2]],
   start = c(rep(0.01,3),0.25,0.7,1.0),
   trace=0,
   mcnr = TRUE)
}
